# 浏览器的原理与实践(1)
### Chrome仅仅打开一个页面，为什么会有4个进程
##### 早期的单进程架构
所有的功能模块都在同一个进程中运行，包括网络，插件，js运行环境等
缺点：
- 不安全
- 不稳定
- 不流畅
##### 多进程架构
将功能分别在对应的进程中实现，浏览器进程可分为：
- 浏览器主进程
- 渲染进程
- GPU进程
- 插件进程
- 网络进程

进程之间通过IPC进程通信，每个进程都是独立运行互不影响，每个Tab页都是独立的渲染进程，js即使阻塞也是阻塞当前页面的渲染，插件和渲染进程都是放到安全沙箱中，恶意程序无法突破沙箱获取系统权限
##### 未来的浏览器架构
面向服务架构，每个进程都是独立的服务，可以解决原有架构高耦合，低内聚，不易扩展的缺点

##### 扩充点：
1. 同一站点，即根域名相同和协议相同
```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```
2. 同一站点的页面，父页面子页面都属于同一站点，一个页面崩溃会导致同一站点的页面全部崩溃

# TCP协议：如何保证页面文件能被完整送达浏览器？
- IP地址，将数据包送达目的主机
- 端口号，将数据包送到目的主机的应用程序

##### 协议
###### UDP
- 携带数据包，IP地址，端口号，将数据包送到目的主机
- 缺点： 不能保证数据点额可靠性，单数传输速度很快，不提供重发功能，适用于音频和视频
###### TCP
- 携带数据包，IP地址，端口号，以及序列号，将数据包送到目的主机
- 面向连接，可靠基于字节流的传输层协议，提供重发功能，并且户按照序列号对数据包进行排序
- 连接需要三次握手，断开需要四次挥手

UDP协议和TCP协议都是传输层协议，HTTP协议是基于TCP协议，是应用层协议

# HTTP请求流程：为什么很多站点第二次打开速度会很快？
##### 浏览器发起HTTP的请求流程
1. 构建请求 GET /index.html HTTP1.1
2. 查找缓存，如果没有缓存则发送请求查询服务器
3. 准备IP地址和端口号，IP地址通过DNS进行解析域名进行查询，DNS第一次查询到之后会进行缓存
4. 等待TCP队列，HTTP1协议规定一次只能发送6个请求
5. 建立TCP连接
##### 服务器处理HTTP请求
1. 返回请求，包含状态码和响应体数据，可以通过命令curl -i https://baidu.com
2. 断开连接，如果需要继续进行查询则不需要断开连接
3. 重定向，可以通过命令curl -I https://baidu.com
##### 为什么很多站点第二次打开速度会很快
第一次查询的时候会将DNS和页面资源缓存起来，一般通过HTTP响应头来设置，Cache-Control:Max-age=2000，如果缓存过期了，需要继续发起网络请求则需要在HTTP请求头中带上，If-None-Match: "4f80f-13c-3a1xb12a"，服务器或根据值来判断资源时候需要更新
##### 登录状态如何保存
浏览器输入用户名和密码发送，服务器验证通过之后会设置响应头尾Set-Cookie: UID-343luad,浏览器接受到之后会缓存起来，再次发送的时候只需要将请求头设置为Cookie: UID=3431uad;服务器接受到之后就会验证是否正确

# 导航流程： 从输入URL到页面展示
1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL
2. 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
3. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程
GET /index.html HTTP1.1
4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程
5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。
6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输
8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层
9. 底层通过物理网络传输给目的服务器主机
10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层
11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层
12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段：
Cache-Control:Max-age=2000
响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程
13. 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度
Connection:Keep-Alive
14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染
15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来
# 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
#### 如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？
1. 不会阻塞dom树的构建，原因Html转化为dom树的过程，发现文件请求会交给网络进程去请求对应文件，渲染进程继续解析Html。
2. 会阻塞页面的显示，当计算样式的时候需要等待css文件的资源进行层叠样式。资源阻塞了，会进行等待，直到网络超时，network直接报出相应错误，渲染进程继续层叠样式计算
3. 
```
当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：
<html>
    <body>
        极客时间
        <script>
        document.write("--foo")
        </script>
    </body>
</html>
那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：
<html>
    <body>
        极客时间
        <script type="text/javascript" src="foo.js"></script>
    </body>
</html>
这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。

我们再看第三种情况，还是看下面代码：
<html>
    <head>
        <style type="text/css" src = "theme.css" />
    </head>
    <body>
        <p>极客时间</p>
        <script>
            let e = document.getElementsByTagName('p')[0]
            e.style.color = 'blue'
        </script>
    </body>
</html>
当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。


所以JS和CSS都有可能会阻塞DOM解析
```

##### 渲染进程：

1. 构建Dom树，document可以查看Dom树
2. 构建Css结构，document.styleSheets可以查看
3. 转换样式表中的属性值，1em => 16px, blue => rgb()等
4. 计算出DOM树中每个节点的具体样式, 继承和形成层叠样式
```
graph LR
渲染进程-->构建Dom树
渲染进程-->样式计算
样式计算-->把CSS转换为浏览器能够理解的结构
样式计算-->转换样式表中的属性值使其标准化
样式计算-->计算出DOM树中每个节点的具体样式
渲染进程-->布局阶段
布局阶段-->创建布局树,计算元素的布局信息
布局阶段-->布局计算
渲染进程-->对布局树进行分层
对布局树进行分层-->拥有层叠上下文属性的元素会被提升为单独的一层
对布局树进行分层-->需要剪裁的地方也会被创建为图层
渲染进程-->绘制列表
绘制列表-->提交到合成线程
渲染进程-->合成线程
合成线程-->将图层分成图块并在光栅化线程池中将图块转换成位图
渲染进程-->合成线程发送DrawQuad给浏览器进程
渲染进程-->生成页面
```
1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

##### 重排
需要重新计算布局信息，需要更新完成的渲染流水线

##### 重绘
需要重新进入绘制阶段，相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些

##### 直接合成阶段
使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作

# 变量提升：JavaScript代码是按顺序执行的吗
js代码执行过程：
1. 编译阶段
2. 执行阶段

##### 编译阶段
编译阶段生成执行上下文和可执行环境，并且发生变量提升，变量提升存储在执行上下文的变量环境中

##### 执行阶段
JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行

总结：

1. JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译
2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数
3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的

# 调用栈：为什么JavaScript代码会出现栈溢出
总结：

1. 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码
2. 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶
3. 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈
4. 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题

# 块级作用域：var缺陷以及为什么要引入let和const
变量提升所带来的问题
1. 变量容易在不被察觉的情况下被覆盖掉

```
var myname = "极客时间"
function showName(){ 
    console.log(myname); 
    if(0){ 
        var myname = "极客邦" 
    } 
    console.log(myname);
}
showName()
```

2. 本应销毁的变量没有被销毁

```
function foo(){ 
    for (var i = 0; i < 7; i++) { } 
    console.log(i); 
}
foo()
```

JavaScript 引擎是通过变量环境实现函数级作用域的，通过词法环境支持块级作用域

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了
- 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中
- 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中

##### 拓展
在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

var的创建和初始化被提升，赋值不会被提升

let的创建被提升，初始化和赋值不会被提升

function的创建、初始化和赋值均会被提升

# 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的
##### 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符

##### 作用域链
javascript查找变量的路径：
1. 当前执行上下文
2. 当前词法作用域的外部引用
3. 调用栈环境

##### 闭包
在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包

个人理解：
调用外部函数返回的内部函数在外部作用域依旧可以访问外部函数的变量

##### 闭包是怎么回收的
如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存

如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量
